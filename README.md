# RADIO WAZOO

## Prerequisites

- ESP-IDF v5.0 or later installed and configured
- Python 3.8+ with pip
- Serial port access (user in `dialout` or `uucp` group on Linux)

## Quick Start

### 1. ESP-IDF Environment

Source the ESP-IDF environment in your terminal:

```bash
. $HOME/esp/esp-idf/export.sh
```

Or if you have `IDF_PATH` set:
```bash
. $IDF_PATH/export.sh
```

You need to do this in every new terminal session before running `idf.py` commands.

### 2. Partition Table Setup

The project includes partition table templates for different flash sizes. Choose one based on your ESP32 module:

**Create your partition table:**
```bash
cp partitions_4MB.csv partitions.csv  # For 4MB flash (most common)
```

**Available templates:**
- `partitions_2MB.csv` - 1.28MB app, 704KB storage
- `partitions_4MB.csv` - 1.5MB app, 2.4MB storage
- `partitions_8MB.csv` - 2MB app, 5.9MB storage
- `partitions_16MB.csv` - 3MB app, 13MB storage

Customize `partitions.csv` for your project needs (e.g., adjust storage size for web assets). The file is gitignored as it's project-specific.

### 3. Target Configuration

The project uses ESP-IDF's automatic config merging for multi-target support:

**Set your target chip:**
```bash
idf.py set-target esp32s2  # or esp32, esp32s3, esp32c3, etc.
```

**Configuration files:**
- `sdkconfig.defaults` - Universal settings (all chips)
- `sdkconfig.defaults.esp32s2` - ESP32-S2 specific (USB CDC console)

ESP-IDF automatically merges the appropriate chip-specific config. To add support for other chips, create `sdkconfig.defaults.<chip>` files.

### 4. Building Web Assets

The web interface files need to be minified and processed before being flashed to the device.

1. **Create a Python virtual environment:**
   ```bash
   python -m venv .venv
   ```
   This creates an isolated Python environment to avoid conflicts with system packages.

2. **Activate the virtual environment:**
   ```bash
   source .venv/bin/activate
   ```
   On Windows, use `.venv\Scripts\activate` instead.

3. **Install build dependencies:**
   ```bash
   pip install -r requirements.txt
   ```
   This installs Invoke (task runner), rcssmin (CSS minifier), rjsmin (JavaScript minifier), and pyserial (device communication). The esptool for flashing is provided by ESP-IDF.

4. **Build the web assets:**
   ```bash
   invoke build
   ```
   This processes files from `src/www/` and outputs minified versions to `data/www/`.

   To see all available tasks, run `invoke --list`.

**Note about the data/ directory:**
- `data/` is the root directory for the device's filesystem
- `data/www/` contains web interface files (generated by `invoke build`)
- You can add other subdirectories to `data/` for application configs, logs, etc.
- The entire `data/` directory gets packed into a LittleFS image and flashed to the storage partition

### 5. Configure Serial Port (Optional)

The default serial port is `/dev/ttyACM0` with baud rate `460800`. If your device uses a different port, edit `tasks.py`:

```python
PORT = "/dev/ttyUSB0"  # or your device path
BAUD = "460800"        # adjust if needed
```

On Linux, ensure your user is in the `dialout` or `uucp` group:
```bash
sudo usermod -a -G dialout $USER  # Debian/Ubuntu
sudo usermod -a -G uucp $USER     # Arch/Manjaro
```

Log out and back in for group changes to take effect.

### 6. Build and Flash Firmware

Once everything is configured, you can build and flash:

**Option 1: Using Invoke tasks (automated):**
```bash
invoke flash
```
This will:
- Check permissions
- Verify device connection
- Build firmware
- Flash bootloader, partition table, and firmware

**Option 2: Using idf.py directly:**
```bash
idf.py build
idf.py -p /dev/ttyACM0 flash
```

**Monitor serial output:**
```bash
idf.py -p /dev/ttyACM0 monitor
```

Or combine all steps:
```bash
idf.py build flash monitor
```

## Project Structure

```
radio-wazoo/
├── main/                   # Application code
│   ├── main.c             # Entry point
│   └── CMakeLists.txt
├── components/            # Custom ESP-IDF components
│   ├── webserver/        # HTTP server
│   └── access_point/     # WiFi AP
├── src/
│   └── www/              # Web interface source files (editable)
├── data/                 # Filesystem root (flashed to device)
│   ├── www/              # Processed web files (generated by invoke build)
│   └── ...               # Other data (configs, logs, etc.) can be added here
├── build/                # Build artifacts (generated)
│   └── littlefs.bin      # Filesystem image (generated)
├── partitions*.csv       # Partition table templates
├── sdkconfig.defaults*   # ESP-IDF configuration
├── tasks.py              # Build automation (Invoke)
└── requirements.txt      # Python dependencies
```

**Key directories:**
- `src/www/` - Edit web files here
- `data/` - Root of device filesystem (entire directory is flashed)
- `data/www/` - Generated from `src/www/` via `invoke build`
- Add other `data/` subdirectories as needed for your application

## Available Invoke Tasks

Run `invoke --list` to see all tasks:

- `invoke build` - Process web assets (src/www/ → data/www/)
- `invoke flash` - Build and flash firmware (checks permissions & device)
- `invoke build-firmware` - Build firmware only
- `invoke flash-firmware` - Flash firmware only
- `invoke flash-filesystem` - Flash data/ directory to storage partition (requires mklittlefs)
- `invoke check-permissions` - Verify serial port access
- `invoke check-device` - Check if device is connected

## Flashing Filesystem (Optional)

To flash the entire `data/` directory (web files, configs, etc.) to the device's storage partition, you need the `mklittlefs` tool:

**Install mklittlefs:**
- Download from: https://github.com/earlephilhower/mklittlefs/releases
- Extract and place in your PATH

**Flash filesystem:**
```bash
invoke flash-filesystem
```

The task will:
- Read partition table to find storage partition
- Create LittleFS image from entire `data/` directory contents
- Flash image to the storage partition
- Skip rebuild if files haven't changed (use `--force` to rebuild anyway)

**Filesystem structure:**
- `data/www/` → `/www/` on device (web interface files)
- `data/configs/` → `/configs/` on device (if you add configs)
- Any other `data/*` directories are preserved in the filesystem

**Note:** If `mklittlefs` is not installed, the device will boot with an empty filesystem. You can upload files after boot using a file upload mechanism in your application.
